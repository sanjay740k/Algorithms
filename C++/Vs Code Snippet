{
	"GCode": {
		"prefix": "gc",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"#define int long long",
			"#define fi first",
			"#define se second",
			"#define pb push_back",
			"#define pr pair<int,int>",
			"#define PI 3.1415926535897932384626",
			"#define mod 1000000007",
			"#define fo(i,n) for(i=0;i<n;i++)",
			"#define endl \"\\n\"",
			"#define mset(m,v) memset(m,v,sizeof(m))",
			"#define max3(a,b,c) max(a,max(b,c))",
			"#define min3(a,b,c) min(a,min(b,c))",
			"typedef vector<int>   vi;",
			"#define FAST_IO  ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL)",
			"const int N=100005;",
			"",
			"void solve()",
			"{",
			"    int n,k,i,ans=0;",
			"    cin >> n >> k;",
			"    vi a(n);",
			"    for(i=0;i<n;i++){",
			"        cin >> a[i];",
			"    }",
			"    //sort(a.begin(),a.end());",
			"    ",
			"    cout << ans << endl;",
			"}",
			"",
			"int32_t main()",
			"{",
			"    FAST_IO;",
			"    #ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\",\"r\",stdin);",
			"    freopen(\"output.txt\",\"w\",stdout);",
			"    #endif",
			"    int t=1;cin>>t;",
			"    for(int i=1;i<=t;i++){solve();}",
			"    return 0;",
			"}"
		],
		"description": "GCode"
	},
	"GCforLocal": {
		"prefix": "gcll",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"#define int long long",
			"#define fi first",
			"#define se second",
			"#define pb push_back",
			"#define pr pair<int,int>",
			"#define endl \"\\n\"",
			"typedef vector<int>   vi;",
			"const int N=100005;",
			"",
			"void solve()",
			"{",
			"    int n,k,i,ans=0;",
			"    cin >> n >> k;",
			"    int a[n];",
			"    for(i=0;i<n;i++){",
			"       cin >> a[i];",
			"    }",
			"    //sort(a,a+n);",
			"    ",
			"    //if()cout << \"Yes\" << endl; else cout << \"No\" << endl;",
			"    cout << ans << endl;",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);",
			"    #ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\",\"r\",stdin);",
			"    freopen(\"output.txt\",\"w\",stdout);",
			"    #endif",
			"    int t=1;cin>>t;",
			"    for(int i=1;i<=t;i++){solve();}",
			"    return 0;",
			"}"
		],
		"description": "GCforLocal"
	},
	"PowerFunction": {
		"prefix": "powerf",
		"body": [
			"",
			"int power(int a,int b,int m=mod)",
			"{",
			"    if(b==0)    return 1;",
			"    if(b==1)    return a;",
			"    int res=power(a,b/2,m);",
			"    res=(res*res)%m;",
			"    if(b&1) res=(res*a)%m;",
			"    return res;",
			"}",
			""
		],
		"description": "PowerFunction"
	},
	"ModFunction": {
		"prefix": "mf",
		"body": [
			"",
			"int power(int a,int b,int m=mod)",
			"{",
			"    if(b==0)    return 1;",
			"    if(b==1)    return a;",
			"    int res=power(a,b/2,m);",
			"    res=(res*res)%m;",
			"    if(b&1) res=(res*a)%m;",
			"    return res;",
			"}",
			"int modinv(int a,int m=mod){ return power(a,m-2,m);}",
			"int add(int a,int b,int m=mod){   int c=(a%m+b%m); if(c>=m) c-=m; return c;}",
			"int sub(int a,int b,int m=mod){   int c=(a%m-b%m); if(c<0)  c+=m; return c;}",
			"int mul(int a,int b,int m=mod){   return (a*b)%m;}",
			""
		],
		"description": "ModFunction"
	},
	"BFS Function": {
		"prefix": "bfsf",
		"body": [
			"",
			"vector<int> ar[N];",
			"int vis[N],dist[N];",
			" ",
			"void bfs(int v){",
			"    queue<int> q;",
			"    q.push(v);",
			"    vis[v]=1;",
			"    dist[v]=0;",
			"    while(!q.empty()){",
			"        int cur=q.front();",
			"        q.pop();",
			"        for(int x : ar[v]){",
			"            if(vis[x] == 0){",
			"                q.push(x);",
			"                dist[x]=dist[cur]+1;",
			"                vis[x]=1;",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "BFS Function"
	},
	"DFS Function": {
		"prefix": "dfsf",
		"body": [
			"",
			"vector<int> ar[N];",
			"int vis[N];",
			"",
			"void dfs(int v){",
			"    vis[v]=1;",
			"    for(int x : ar[v]){",
			"        if(vis[x] == 0)",
			"            dfs(x);",
			"    }",
			"}",
			""
		],
		"description": "DFS Function"
	},
	"Graph Solve Function": {
		"prefix": "graphf",
		"body": [
			"void solve()",
			"{",
			"    int n,a,b,i; ",
			"    cin >> n ;",
			"    for(i=1;i<n;i++){",
			"        cin >> a >> b;",
			"        ar[a].pb(b);",
			"        ar[b].pb(a);",
			"    }",
			"    cout << endl;",
			"}"
		],
		"description": "Graph Solve Function"
	},
	"Sieve Function": {
		"prefix": "sievef",
		"body": [
			"",
			"bool c[N];",
			"vector<int> v;",
			"void sieve()",
			"{",
			"    int i,j;",
			"    for(i=2;i<N;i++){",
			"        if(!c[i]){ ",
			"            v.pb(i);",
			"            for(j=i*i;j<N;j+=i)c[j]=true;",
			"        }",
			"    }",
			"} ",
			""
		],
		"description": "Sieve Function"
	},
	"Help Function": {
		"prefix": "helpf",
		"body": [
			"",
			"//    :: scope resolution operator, ::x will always refer to global x",
			"//    x<<1 => x*2    x>>1 => x/2;    cout.flush();",
			"//    cout << fixed << setprecision(10) << ans << endl;",
			"//    cout << setw(10) << ans;    //  Right justified",
			"//    s.substr(i,n);",
			"//    vector<vector<int>> v(n, vector<int> (m, 0));",
			"//    vector <int>::iterator it;",
			""
		],
		"description": "Help Function"
	},
	"Struct Function": {
		"prefix": "structf",
		"body": [
			"",
			"struct xyz{",
			"    private:",
			"        int a,b,c;",
			"    public:",
			"        void input(){    //xyz v1; v1.input();",
			"            cin >> a >> b >> c;",
			"        }",
			"        void showdata(){    //v1.showdata();",
			"            cout >> a >> ' ' >> b >> ' ' >> c >> endl;",
			"        }",
			"};    //,v2;    //v2 is global object.",
			""
		],
		"description": "Struct Function"
	},
	"Class Function": {
		"prefix": "classf",
		"body": [
			"",
			"class xyz{",
			"    private:",
			"        int a,b;",
			"        //static float roi;",
			"    public:",
			"        void input(){    //xyz v1; v1.input();",
			"            cin >> a >> b ;",
			"        }",
			"        void showdata(){    //v1.showdata();",
			"            cout >> a >> ' ' >> b >> endl;",
			"        }",
			"        //void setdata(int, int);",
			"        //static void setroi(float x){ roi = x; }",
			"};    //,v2;    //v2 is global object.",
			"/*void xyz:: setdata(int x, int y){    //Membership Label",
			"    a=x;",
			"    b=y;",
			"}*/",
			"//float xyz:: roi=3.5;    //xyz::setroi(4.5); //in main()",
			""
		],
		"description": "Class Function"
	},
	"NCR Function": {
		"prefix": "ncr",
		"body": [
			"",
			"int ncr(int n, int r)",
			"{",
			"    int p=1, k=1, m;",
			"    if(n-r < r) r = n-r;",
			"    if(r!= 0){",
			"        while(r){",
			"            p *= n;  k *= r;",
			"            m = __gcd(p, k);",
			"            p /= m;  k /= m;",
			"            n--;     r--;",
			"        }",
			"    }",
			"    return p;",
			"}",
			""
		],
		"description": "NCR Function"
	},
	"Binary Search Function": {
		"prefix": "binarysf",
		"body": [
			"",
			"bool solve(int a[],int k)",
			"{",
			"    int l=0,r=n-1,m;",
			"    while(r>=l){",
			"        m=(r+l)/2;",
			"        if(a[m]>k){",
			"            r=m-1;",
			"        }",
			"        else if(a[m]<k){",
			"            l=m+1;",
			"        }",
			"        else {",
			"            return true;",
			"        }",
			"    }",
			"    return false;",
			"}",
			""
		],
		"description": "Binary Search Function"
	},
	"Segment Tree Function": {
		"prefix": "segtree",
		"body": [
			"",
			"int st[400001], arr[100001], n;",
			"",
			"void build(int x, int lx, int rx)",
			"{",
			"    if(rx-lx == 1)",
			"    {",
			"        if(lx<n)",
			"        st[x] = arr[lx];",
			"        return;",
			"    }",
			"    int m = (lx + rx)/2;",
			"    build(2*x+1 , lx , m);",
			"    build(2*x+2 , m , rx);",
			"    st[x] = st[2*x+1] + st[2*x+2];",
			"}",
			"",
			"int query(int x, int l, int r, int lx, int rx)",
			"{",
			"    if(lx>=r || l>=rx)   return 0;",
			"    if(lx>=l && rx<=r)   return st[x];",
			" ",
			"    int m = (lx+rx)/2;",
			"    int s1 = query(2*x+1 , l , r , lx , m);",
			"    int s2 = query(2*x+2 , l , r , m , rx);",
			"    return (s1 + s2);",
			"}",
			"",
			"void update(int i , int x , int lx , int rx){",
			"    if(rx - lx == 1){",
			"        st[x]=arr[i];",
			"        return ;",
			"    }",
			"    int m = (lx+rx)/2;",
			"    if(i < m) update(i , 2*x+1 , lx , m);",
			"    else      update(i , 2*x+2 , m , rx);",
			"    st[x]=(st[2*x+1]+st[2*x+2]);",
			"}",
			""
		],
		"description": "Segment Tree Function"
	},
	"LIS Function": {
		"prefix": "lis",
		"body": [
			"",
			"int lis(vector<int> A) {",
			"    int i,j,n=A.size();",
			"    int v[n],ans=0;",
			"    for(i=0;i<n;i++){",
			"        v[i]=1;",
			"        for(j=0;j<i;j++){",
			"            if(A[i]>A[j]) v[i] = max(v[i] , v[j]+1);",
			"        }",
			"    }",
			"    for(i=0;i<n;i++) ans = max(v[i] , ans);",
			"    return ans;",
			"}",
			""
		],
		"description": "LIS Function"
	},
	"Is Prime Function": {
		"prefix": "isprime",
		"body": [
			"",
			"bool isprime(int n){",
			"    int i,x=sqrt(n);",
			"    for(i=2;i<=x;i++){",
			"        if(n%2==0) return false;",
			"    }",
			"    return true;",
			"}",
			""
		],
		"description": "Is Prime Function"
	}
}
